import pytest
from bella import cayley
from mpmath import mp

def matrix_almosteq_up_to_sign(M,N):
    return matrix_almosteq(M,N) or matrix_almosteq(M,-N)

def matrix_almosteq(M,N, tol=None):
    return mp.almosteq(M[0,0],N[0,0],abs_eps=tol) and mp.almosteq(M[1,0],N[1,0],abs_eps=tol) and mp.almosteq(M[0,1],N[0,1],abs_eps=tol) and mp.almosteq(M[1,1],N[1,1],abs_eps=tol)\
      and M.rows == 2 and M.cols == 2 and N.rows == 2 and N.cols == 2

def test_generators_from_circle_inversions():
    circle_1 = (0, 1) # unit circle
    line_1 = (0, 1) # line through 0 and 1

    # For orthogonal reflections A and B, AB = (BA)^-1 since A and B commute.
    orthogonal_gens = cayley.generators_from_circle_inversions([circle_1], [line_1])
    assert matrix_almosteq_up_to_sign(orthogonal_gens[0] @ orthogonal_gens[0], mp.eye(2))

    circle_2 = (2+3j, 2)

    # Result of this should be [AB] where A is inversion in circle 1 and B is inversion in circle 2.
    gens1 = cayley.generators_from_circle_inversions([circle_1,circle_2], [])
    # Result of this should be [BA].
    gens2 = cayley.generators_from_circle_inversions([circle_2,circle_1], [])
    assert len(gens1)==1
    assert len(gens2)==1
    assert matrix_almosteq_up_to_sign(gens1[0] @ gens2[0], mp.eye(2))

    # More complicated. Let us take the group generated by inversions in circle_1 and circle_2.
    # The action of the generator AB should be to take any point outside circle_2 and move it into circle_1.
    projective_point = gens2[0] @ mp.matrix([[4+3j],[1]])
    assert mp.fabs(projective_point[1]/projective_point[0] - circle_1[0]) < circle_1[1]
    projective_point = gens2[0] @ mp.matrix([[0],[1]])
    assert mp.fabs(projective_point[1]/projective_point[0] - circle_1[0]) < circle_1[1]
    projective_point = gens2[0] @ mp.matrix([[1j],[1]])
    assert mp.fabs(projective_point[1]/projective_point[0] - circle_1[0]) < circle_1[1]


    circle_3 = (-3+0.001j, 0.4)
    lots_of_gens = cayley.generators_from_circle_inversions([circle_2,circle_1,circle_3], [line_1])
    assert len(lots_of_gens) == 4 # C2 C1, C1 C3, C3 L1, L1 C2


    # Now we test some geometry.
    line_2 = (0,1+1j) #45degree line
    rotgroup = cayley.generators_from_circle_inversions([], [line_2, line_1])
    #Generator of this group should be a rotation anticlockwise by 2*45=90 degrees.
    rot = mp.matrix([[1j,0],[0,1]])
    rot = 1/mp.sqrt(cayley.simple_det(rot)) * rot
    assert matrix_almosteq_up_to_sign(rotgroup[0], rot)

    line_3 = (0+2j, 1+1j+2j) # shift of line_2 up by 2j
    shiftgroup = cayley.generators_from_circle_inversions([], [line_3, line_2])
    #Generator of this group should be a translation by 2*2*cos(pi/4)*exp(i*3pi/4)
    shift = mp.matrix([[1,4*mp.cos(mp.pi/4)*mp.exp(3j*mp.pi/4)],[0,1]])
    assert matrix_almosteq_up_to_sign(shiftgroup[0], shift)

    # Take two tangent circles. Inversion in one times inversion in the other should be parabolic with fixed point
    # at the point of intersection.
    circle_4 = (2,1)
    parabolic_gens = cayley.generators_from_circle_inversions([circle_1,circle_4],[])
    G = cayley.GroupCache(parabolic_gens)
    assert cayley.simple_tr(G[(0,)])**2 == 4
    assert G.fixed_points((0,))[0] == 1

def test_basic_invariants():
    bad_det = mp.matrix([[1,2],[3,4]])
    with pytest.warns(cayley.NonUnitDeterminantWarning) as e_info:
        assert cayley.GroupCache([bad_det])
    λ = 2+3j
    X = mp.matrix([[λ,0],[0,λ**-1]])
    Y = mp.matrix([[-1j*(4+3j), -1j],[-1j, 0]])
    G = cayley.GroupCache([X,Y])
    assert len(G) == 2
    assert G[(0,)] == X
    assert G[(1,)] == Y
    assert matrix_almosteq(G[G.inv_word((0,))], X**-1)
    assert matrix_almosteq(G[G.inv_word((1,))], Y**-1)
    assert matrix_almosteq(G[(1,0)], Y*X)
    assert not G.is_reduced_from_left((0,) + G.inv_word((0,))) # Xx is not reduced
    assert G.is_reduced_from_left((0,) + G.inv_word((1,))) # Xy is reduced

def test_simple_matrix_formulae():
    X = mp.matrix([[1,2],[-3j,0.1]])
    assert cayley.simple_tr(X) == mp.mpf(1) + mp.mpf(0.1)
    assert cayley.simple_det(X) == 1*0.1 - 2*(-3j)
    assert cayley.simple_inv(X) == 1/(cayley.simple_det(X)) * mp.matrix([[0.1,-2],[3j,1]])

    β = mp.exp(mp.pi/3)
    Y = mp.matrix([[β, 1], [0, β**-1]])
    fp = cayley.mobius_fixed_points(Y)
    assert fp[0] == mp.inf
    assert mp.almosteq(fp[1], (Y[0,0]*fp[1] + Y[0,1])/(Y[1,0]*fp[1] + Y[1,1]))

def test_normalisation():
    X = mp.matrix([[1,1],[0,1]])
    Y = mp.matrix([[1,0],[3+2j,1]])
    M = mp.matrix([[1, 2+3j], [(2-3j)/13, 2]])

    N1 = cayley.normalise_mobius_pair(X,Y)
    assert matrix_almosteq(N1, mp.matrix([[1,0],[0,1]]))

    N2 = cayley.normalise_mobius_pair(Y,X)
    assert matrix_almosteq(X, N2 @ Y @ N2**-1)

    N = cayley.normalise_mobius_pair(M @ X @ M**-1, M @ Y @ M**-1)
    assert mp.almosteq(cayley.simple_det(N), 1)

    assert matrix_almosteq(N @ M @ X @ M**-1 @ N**-1, X, 1e-50)
    assert matrix_almosteq(N @ M @ Y @ M**-1 @ N**-1, Y, 1e-50)

def test_circle_space():
    horizontal_line = cayley.circle_through_points(0+2j, 1+2j, mp.inf)
    assert horizontal_line[3] != 0
    assert horizontal_line/horizontal_line[3] == mp.matrix([0,0,1/4,1])

    C2 = cayley.circle_in_circle_space(-.25j, 1/4)
    assert C2/C2[0] == mp.matrix([1,0,-1/4,0])

    C1 = cayley.circle_through_points(0, -0.5j, .2-.4j)
    assert mp.chop(C1/C1[0],10**-10) == mp.matrix([1,0,-1/4,0])

    mult_inverse = cayley.action_on_circles(mp.matrix([[0,1j],[1j,0]]))
    M1L1 = mult_inverse @ horizontal_line
    mp.nprint(C1)
    mp.nprint(M1L1)
    assert mp.chop(M1L1/M1L1[0],10**-10) == mp.chop(C1/C1[0], 10**-10)

    vertical_line = cayley.line_in_circle_space(0, 1j)
    translation = mp.matrix([[1,1],[0,1]])
    line2 =  cayley.action_on_circles(translation) @ vertical_line
    assert 2*line2/line2[3] == mp.matrix([0,1,0,2])
    translation = mp.matrix([[1,1],[0,1]])
    line3 =  cayley.action_on_circles(translation) @ horizontal_line
    assert line3/line3[3] == horizontal_line/horizontal_line[3]

    unit_circle = cayley.circle_in_circle_space(0+0j, 1)
    assert unit_circle/unit_circle[0] == mp.matrix([1, 0, 0, -1])
    assert cayley.circle_space_to_circle_or_line(unit_circle) == [0, 1, False]

    M = cayley.action_on_circles(mp.matrix([[0,-1],[1,0]]))
    assert M.rows == 4 and M.rows == 4 and mp.det(M) != 0
    image_of_unit_circle = M @ unit_circle
    assert image_of_unit_circle/image_of_unit_circle[0] == unit_circle

    horizontal_line_2 = cayley.circle_through_points(0+0.5j, 0.5+0.5j, mp.inf)
    assert (1/2)*horizontal_line_2/horizontal_line_2[3] == mp.matrix([0,0,1/2,1/2])
    circle_2 = mp.matrix([1,0,-3/8,1/8])
    M = cayley.action_on_circles(mp.matrix([[1,0],[4j,1]]))
    image = M @ horizontal_line_2
    assert mp.chop(image/image[0]) == circle_2
